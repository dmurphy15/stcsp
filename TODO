TODO
make the propagate functions into a class that can be passed
make constraint chooser class
make variable chooser class
make value chooser class


LAYOUT:
solver gets the constraints
from the constraints, it gets variables
variables just have their domains - no evaluation or anything
solver creates instantaneous csps, each with their own set of constraints and all variables
each instantaneous csp makes its own map of variable to assignment


context handles all assignments



in makefile, generate all .o files plus the lex script that solves problems

ask Jasper what the deal was with Array variables wtf are those
also objective statements wtf are those


could binarize all expressions in the beginning, which would reduce their domains
when propagating an equality constraint, could compute domain size on each size, and based on that prune the larger domain first to save time
could represent domains as a list of endpoints of ranges - worst case takes 2x memory, best case is unlimited
add an alldifferent constraint just for fun?
could keep a list of seen failed nodes, to not try them again

ASK ABOUT NORMALIZATION OF THE OTHER THINGS LIKE FIRST, NEXT, FBY, UNTIL
also ask - I think when you normalize an @ expression as in the paper, you need to also have x1 == nex x1???
AT IS BROKEN; FBY IS BROKEN


If still slow, could also look into GAC returning a condensed set of ranges instead of a set of ints...
also in primitiveFirstConstraint, looks like we dump entire domains into sets - do we have to do that?




modularize domains to be more BC friendly and lightweight
change dominance detection to only compare constraints that would change (at, until, first)
first constraints check for tautologies and throw out
